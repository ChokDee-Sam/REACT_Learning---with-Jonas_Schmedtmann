// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Component, Component Instance, and React Element
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Composant :
    - Une description d'un morceau de l'UI
    - Un Template / Blueprint
    - C'est une fonction qui return un React Element (element tree)
        (généralement écrit en JSX)


Component Instance :
    - créé lorsqu'on "utilise" le Composant
    - React appelle en interne le Composant
    - C'est la manifestation "physique" de notre Composant
        (vivant dans le Component Tree)
    - Possède ses propres States / Props
    - Possède son cycle de vie (naît, vit, et meurt)
        (un peu comme un organisme vivant)


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Savoir être précis : ne jamais omettre l'instance de Composant
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    - cycle de vie d'un Composant = cycle de vie d'une INSTANCE de Composant
    - une UI est faite de Composants = une UI est faite d'INSTANCE de Composants


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    JSX  >  React.createElement()  >  React Element
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

1 - Le JSX du Composant est convertit en plusieurs function React.createElement()
2 - Puis React appelle ces function React.createElement()
3 - Ce qui créera des React Elements

Un React Element = le simple fait d'écrire un Composant 

Pour résumer un React Element :
    - c'est le résultat des appels de fonctions (React.createElement)
    - c'est un gros object JavaScript immutable que React garde en mémoire

Mais que contient ce gros Object JS ?
TOUTES les infos nécessaires pour créer les Element Dom de cette Instance de Composant


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    React Element (inseré dans le DOM) >  DOM Element (html)
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

potentiel conversion > Affichage à l'ecran dans le navigateur

Les DOM Elements sont :
    l'actuelle représentation visuelle FINALE de l'instance du Composant
        dans le navigateur

ATTENTION : Ce n'est pas le React Element qui est Render dans le DOM

Les React Elements vivent dans l'App React et ne font rien avec le DOM
ils sont simplement convertit en DOM Element quand ils sont affichés sur écran

// à préciser



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Instances et Elements           $$$type of : Symbol
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Possibilité de voir ce que contient une instance avec un console.log()
    console.log( <ComposantName /> )
    console.log( ComposantName() )

On aura toujours un React.element mais, le deuxieme exemple fera en sorte de :
    - montrer uniquement le type brut (div, etc)
    - modifier la ligne des Props

De ce fait : 
    - React ne pas cela comme une instance de Composant
    - À la place, il voit ça comme un React Element brut

Ce n'est pas ce que nous voulons !

Imaginons utiliser la fonction() plutot que l'instance de Composant
Ses Hooks seront apparants, mais n'appartiendront à aucun Composant...
Donc, impossible de manager ses propres States = ce n'est pas un Composant.

On "utilise un Composant" pour que React le voit comme une instance de Composant
(et pas comme un output element brut)
Et donc, il n'existera pas dans l'Arbre de Composants !

Pour toutes ces raisons, nous pouvons conclure : 
    - ne jamais faire utiliser les fonctions de Composants à la place d'Instances
    - cela nous évitera les problèmes et "violations" des règles de Hooks
    - placer les instances dans du JSX pour être vu en tant que Compo Instances



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Rendering Process
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

1 - Le Render est déclenché 
    par un update de State par exemple

2 - Le Render Phase
    - React appelle la function de Composant
    - React comprend donc comment le DOM doit être Update

3 - Le Commit Phase
    React écrit dans le DOM : Update, insert, et/ou supprime des éléments

4 - Affichage dans le navigateur

Dans React :
    - Le Rendering n'Update pas le DOM, et n'affiche rien de particulier à l'écran
    - Le Rendering se passe uniquement à l'intérieur de React, sans modif visuel



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    2 situations qui font un Trigger Render
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    1 - L'initial Render d'une App
    2 - L'Update d'un State, dans un ou plusieurs Instances de Composants (Re-Render)

Le Processus de Render se déclenche dans l'Application toute entière
Mais ça ne veut pas dire que le DOM tout entier est Update

En pratique :
    On dirait que React Re-Render uniquement le Composant où le State est Update
    mais ce n'est pas ce qui se passe "derrière la scene"

Une précision :
    Les Renders ne sont pas déclenchés immédiatement après un State Update,
    mais programmés quand le moteur JavaScript aura du temps libre (en millisecondes)

    Il y a aussi des cas de figure, comme plusieurs setState dans la même function,
    où les Render seront regroupés dans le gestionnaire d'event



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Le New Virtual DOM
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Re-Render d'un Composant = Re=Render de tous les Composants Enfants


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Le Current Tree Fiber
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    L'arbre interne a une fibre de chaque Instance Composant et des Dom Elements
    Sera modifié (mutable), lors d'un Update, après la Reconciliation/Diffing

    La "Fibre" se compose de : 
        - Current State
        - Props
        - Side Effects
        - Used Hooks
        - Queue of Work

    Le Process peut être Asynchrone selon les taches prioritaires, etc.


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Reconciliation/Diffing  >  Update Fiber Tree
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    Décide quel éléments du DOM a besoin d'être :
        - ajouté
        - supprimé
        - mis à jour

    Avec ces informations, le Fiber Tree va Update


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Update Fiber Tree  >  List of DOM updates
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Après l'Update du Fiber Tree : 
TOUTES les modifications de cet arbre seront placées dans une List of Effects.

Celle ci sera utilisé dans la Phase 3 : Commit Phase


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Phase 3 : Commit Phase      L'utilisation de la List pour ReactDOM
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Ce sera ReactDOM qui modifiera le DOM avec les éléments de cette Liste.

Cette Phase 3 de Commit sera synchro.
Aucune interruptions pour éviter des problèmes, ou des résultats partiels.
Le but est de garantir un UI consistant (constamment en synchro avec les States)

    ReactDOM modifiera le DOM avec :
        - des ajouts
        - des suppressions
        - des mises à jour


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Phase 4 : Browser Paint      L'Update du l'UI dans notre navigateur
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    Une fois que ReactDOM aura terminé la modification du DOM, 
    le navigateur affichera l'UI



//  LES 4 PHASES
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
[1] TRIGGER : intial Render / State Update
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
[2] RENDER PHASE
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
UPDATE React Element
        ⬇️     
  New Virtual DOM           Current Fiber Tree
               ⬇️           ⬇️
             Reconciliation + Diffing
                      ⬇️
               UPDATE Fiber Tree
                      ⬇️
              List of DOM updates
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
[3] COMMIT PHASE
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
                      ⬇️
                  UPDATED DOM
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
[4] BROWSER PAINT
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
                      ⬇️
             UPDATED UI on screen
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Résumé pour comprendre l'essentiel
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Durant la Phase 1 (Trigger)
    - Le but est de déclenchée un Render
    - via l'Initial Render, ou un State Update

Durant la Phase 2 (Render)
    - Le but final de cette phase est de générer une Liste
    - React ne touche pas le DOM !
    - Cette phase ne produit AUCUN output visuel
    - Chaque Composant Render va aussi Render tous ses Composants Enfants
    - Cette Phase peut être Asynchrone (selon le découpage, les priorités, etc)

Durant la Phase 3 (Commit)
    - Le but est que ReactDOM modifie le DOM grace à cette Liste
    - Cette Phase est Synchrone, afin de conserver un UI consistant

Durant la Phase 4 (Browser Paint)
    - De manière automatique, le navigateur va détecter un changement d'UI
    - De ce fait, il l'affichera pour notre utilisateur




// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Comment fonctionne le Diffing
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Le Diffing a 2 manière de procéder :
Cas 1 : 2 éléments de différents types = Nouvel Arbre
Cas 2 : Des éléments avec une "Key Pro Stable" = restent les même durant le Render


Cas 1 : La même Position, mais un élément différent     
        DOM différent, ou React Element (Composant Instance)

        - React suppose que le sous-arbre entier n'est plus valable
        - Les "anciens" élements sont détruits et retirés du DOM (States inclus)
        - L'arbre se reconstruit, le sous-Arbre également, 
          même s'il n'est pas modifié (= State Reset)


Cas 2 : La même Position, avec le même Element  (mais avec des attributs différents)
        DOM similaire, ou React Element (Instance de Composant)

        - Les éléments seront conserver STATE INCLUS 
          (ainsi que les Enfants / sous-branche)
        - Les nouveaux Props / Attribut seront transmis
        - Attention : parfois, ce n'est pas ce qu'on souhaite, donc on utilise Key