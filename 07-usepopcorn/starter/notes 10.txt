// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Hooks
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    Ce sont des fonctions natives, en interne, 
    qui nous permettent de nous "connecter" à l'intérieu de React

        - Créer et acceder aux States depuis le Fiber Tree 
        - Enregistrer un Side Effect dans le Fiber Tree 
        - Selectionner le DOM manuellement
        - Et plein d'autres choses...

    Le nom des Hooks comment toujours avec "use"

    Permet facilement la réutilisation de "Non-Visual Logic"
    On peut composer des multiples Hooks dans notre propre Custom Hook.

    Donne à un Function Composant le droit d'avoir son propre State et Side Effect
    (Avant la version 16.8, la seule possibilité était les Class Composants)



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Plusieurs Hooks
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

Les plus utilisés :
    - useState
    - useEffect
    - useReducer
    - useContext


Les moins utilisés (à apprendre) : 
    - useRef
    - useCallback
    - useMemo
    - useTransition
    - useDeferredValue

Les moins utilisés (à mettre de coté pour le moment)
    - useLayoutEffect
    - useDebugValue
    - useImperativeHandle
    - useImperativeHandle

Uniquement pour les librairies :
    - useSyncExternalStore
    - useInsertionEffect


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Les 2 Règles de Hook
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    1 - Call les Hooks au Top Level
        - Pas de Call dans :
            - une condition
            - une boucle
            - une fonction imbriquée
            - ou après un Early Return

        - Car : les Hooks doivent TOUJOURS être Call dans le même Ordre 


    2 - Les Hooks doivent être Call depuis une Function
        - Call uniquement depuis : 
            - une Function Component
            - ou un Custom Hook


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Les Hooks dépendent de l'Ordre d'Appel      CALL ORDER
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

QUand une App est Render, React crée un React Element Tree (Virtual Dom)
    => Initial Render = Création du Fiber Tree ( en dehors du Virtual Dom)
        => Le Fiber Tree va créer des FIBER : les Props, Liste, Hooks...
            => il y aura une liste d'Appel des Hooks utilisés
                => IL EST INDISPENSABLE QUE LA LINKED LISTE SOIT LA MÊME

Il ne faut pas que les Links soient broken après un Render
Et pour ça, il ne faut pas qu'un Link disparaissent suite à une condition ou autre
React serait "confus"

Les Hooks ont besoin d'être Call dans le même Ordre à chaque Render.
Et le moyen de faire ça, c'est d'appeler les Hooks au Top Level

Pourquoi s'embêter avec cette Linked List qui oblige une règle étrange ?
    La raison est que, cette Linked List, qui est reliée à la Hook Call Ordre,
    est le moyen le plus simple d'associer chaque Hook à sa valeur.

    Fondadamentalement, l'Ordre dans lequel le Hook est appelé 
    identifie de manière UNIQUE le Hook.

    React connait la valeur des States, 
    et ces valeurs sont associées à l'Ordre d'Appel (Call Order)

    La Linked List, est en quelque sorte une liste de valeurs.
    Grace à ça, pas besoin d'attribuer manuellement des noms à chaque Hooks.
    C'est pratique, et cela évite donc certains problèmes.



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    More details of useStates
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    L'initial value d'une State est valable UNIQUEMENT lors de l'initial Render
        (only on Component Mount)
    
    Ce qui peut être constamment valable, c'est une State Derivée, 
    car elle est "regenerée" à chaque re-Render du Composant


    Pour éviter les Stale States (states obsoletes), 
    on passe un callback de la current value



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
    Initialiser la State avec un Callback (Lazy Initial State)
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

    Pour initialser une State avec un local Storage, 2 façons :
        - soit en passant par un State
        - soit en passant par un useEffect

    Le local storage se compose uniquement de key value pairs
        et la value est une String (penser à convertir)